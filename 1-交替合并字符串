class Solution:
  def mergeAlternately(self, word1: str, word2: str)->str:#->str意思是输出为字符串
    i=j=0
    n,m=len(word1),len(word2)
    ans=[]
    while i<n or j<m:
      if i<n:
        ans.append(word1[i])
        i +=1
      if j<m:#为什么不是elif，因为word1和word2的长度不一致，所以是独立的if
        ans.append(word2[j])
        j +=1
    return "".join(ans)#循环结束后，ans中存放的是按顺序排列的单个字符，通过join将字符列表拼接成一个字符串

关于时间复杂度和空间复杂度
时间复杂度：数据规模变大之后，算法会慢到什么程度？
如果你要把 10 本书按顺序摆好，需要看 10 次。
如果你要把 100 本书按顺序摆好，需要看 100 次。
书的数量翻了 10 倍，操作次数也翻了 10 倍。
这种算法的时间复杂度可以理解为“和数据量成正比”，记作 O(n)。

如果你要在 100 个人里，挨个和所有人握手：
第 1 个人要和 99 个人握手
第 2 个人要和 98 个人握手
总共要握很多很多次
当人数翻倍时，握手次数会变成原来的四倍左右。
这种算法“慢得非常快”，时间复杂度就是 O(n²)。

空间复杂度：数据规模变大后，算法会占用多少额外内存？

如果你只是算一道数学题：
只用一张纸、一支笔
不管题目多大，桌面都没怎么变
这种情况，空间复杂度就是 O(1)，意思是“占用空间基本不变”。

如果你要把 1000 个名字抄到一个本子里：
名字越多，本子就越厚
名字翻倍，占用空间也翻倍
这种情况，空间复杂度就是 O(n)。
      
